# ğŸ¤– AI Development Rules

**Essential workflow before modifying the codebase**

---

## âš¡ Pre-Coding Checklist

- [ ] Is it secure? (No exposed secrets)
- [ ] Server-side verified? (Payment/auth)
- [ ] Error handling added?
- [ ] Matches existing patterns?
- [ ] No console.log in prod?
- [ ] Using env variables?
- [ ] Response format correct?
- [ ] Tested with valid & invalid input?

---

## ğŸ” Critical Security Rules

**ALWAYS**:
```javascript
// Server-side payment verification
const hmac = crypto.createHmac('sha256', process.env.RAZORPAY_KEY_SECRET);
if (hmac.digest('hex') !== receivedSignature) return error;

// Environment variables for secrets
const secret = process.env.RAZORPAY_KEY_SECRET;

// Validate on backend
if (!req.body.email || !req.body.email.includes('@')) return error;
```

**NEVER**:
```javascript
// Hardcoded secrets
const secret = 'rzp_live_xxxxx';

// Client-side verification
if (req.body.signature === expected) { /* Can be tampered! */ }

// Trust frontend validation only
if (req.headers.userId) { /* Client could fake this */ }
```

---

## ğŸ“ Response Format (ALWAYS use this)

```javascript
// Success
{ error: false, success: true, message: "...", data: {...} }

// Error
{ error: true, success: false, message: "User-friendly message" }
```

---

## ğŸ¯ API Endpoint Pattern

```javascript
// routes/order.route.js
router.post('/orders', middleware, orderController.create);

// controllers/order.controller.js
export const create = async (req, res) => {
  try {
    // 1. Validate
    if (!req.body.totalAmt || req.body.totalAmt <= 0) {
      return res.status(400).json({ error: true, message: "Invalid amount" });
    }
    
    // 2. Process
    const order = await OrderModel.create(req.body);
    
    // 3. Respond
    res.status(201).json({ error: false, success: true, data: order });
  } catch (error) {
    console.error("Create order error:", error);
    res.status(500).json({ error: true, message: "Failed to create order" });
  }
};
```

---

## ğŸ’¾ Database Pattern

```javascript
// âœ… Schema with validation & indexes
const schema = new Schema({
  email: { type: String, required: true, unique: true },
  status: { type: String, enum: ['pending', 'confirmed'], required: true }
}, { timestamps: true });
schema.index({ paymentId: 1 });

// âœ… Query optimized
const user = await UserModel.findById(id).select('name email').lean();

// âŒ No validation, return all fields
const user = await UserModel.findById(id);
```

---

## ğŸ›’ Order Status Rules

**Flow**: 
```
pending â”€â”€â†’ confirmed â”€â”€â†’ shipped â”€â”€â†’ delivered âœ“
                      â†“
                  cancelled âœ—
```

**On Create**:
```javascript
{ order_status: "pending", payment_status: "pending" }
```

**After Payment Verified**:
```javascript
{ order_status: "confirmed", payment_status: "paid" }
```

**If Payment Fails**:
```javascript
{ order_status: "cancelled", payment_status: "failed" }
```

---

## âš›ï¸ React Hook Pattern

```jsx
export default function CheckoutPage() {
  const [data, setData] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  const handleSubmit = async () => {
    try {
      setIsLoading(true);
      setError(null);
      const res = await fetch('/api/orders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });
      
      if (!res.ok) throw new Error('Failed');
      
      const json = await res.json();
      setData(json.data);
    } catch (err) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div>
      {error && <div className="error">{error}</div>}
      <button disabled={isLoading} onClick={handleSubmit}>
        {isLoading ? 'Processing...' : 'Submit'}
      </button>
    </div>
  );
}
```

---

## ğŸ§ª Testing Rules

**Before committing**:
1. Test success case
2. Test with invalid input (should error)
3. Verify database updated correctly
4. Check response format matches API spec
5. No console errors/warnings

**For payment features**:
- Use test card: `4111 1111 1111 1111`
- Test invalid signature rejection
- Verify order status updates
- Check admin dashboard notification

---

## ğŸ“ API Naming

```
âœ… GET  /api/orders              (list)
âœ… POST /api/orders              (create)
âœ… PUT  /api/orders/:id/status   (update)

âŒ /api/getOrders, /api/createOrder (wrong methods)
```

---

## ğŸ”„ Payment Flow (Step-by-Step)

```
1. Frontend: POST /api/orders
   â†’ Returns razorpayOrderId

2. Razorpay modal opens
   â†’ User pays with test card

3. Frontend: POST /api/orders/verify-payment
   â†’ Sends: orderId, paymentId, signature

4. Server: Verify signature
   â†’ If valid: update to "confirmed" & "paid"
   â†’ If invalid: reject (fraud)

5. Frontend: Redirect to /my-orders
   â†’ Order shows "confirmed"

6. Admin: See notification
   â†’ Update status to "shipped"

7. Customer: See status update
   â†’ Tracks delivery
```

---

## ğŸš« Common Mistakes

```javascript
// âŒ WRONG: Hardcoded secrets
const key = 'rzp_live_xxx';

// âœ… RIGHT: Environment variables
const key = process.env.RAZORPAY_KEY_ID;

// âŒ WRONG: No error handling
const data = await fetch(url).then(r => r.json());

// âœ… RIGHT: Proper error handling
try {
  const res = await fetch(url);
  if (!res.ok) throw new Error('Request failed');
  const data = await res.json();
} catch (err) {
  console.error('Error:', err);
  // Handle error
}

// âŒ WRONG: Console.log in production
console.log('User:', user);

// âœ… RIGHT: Conditional logging
if (process.env.NODE_ENV === 'development') {
  console.error('Error:', error);
}
```

---

## ğŸ“‹ File Structure

```
server/
â”œâ”€â”€ controllers/     â†’ Business logic
â”œâ”€â”€ models/          â†’ Database schemas
â”œâ”€â”€ routes/          â†’ API endpoints
â”œâ”€â”€ middlewares/     â†’ Auth, validation
â””â”€â”€ config/          â†’ Configuration

frontend/client/
â”œâ”€â”€ app/             â†’ Pages
â”œâ”€â”€ components/      â†’ React components
â”œâ”€â”€ hooks/           â†’ Custom hooks (usePayment, etc)
â””â”€â”€ contexts/        â†’ Context providers
```

---

## âœ… Verification Before Pushing

1. No hardcoded secrets in code
2. Error handling with try-catch
3. Validation on server-side
4. Response format correct
5. Database queries optimized
6. Tests pass (valid & invalid input)
7. No console.log in production code
8. Follows existing patterns
9. Documented with comments
10. Security verified

---

**Last Updated**: January 25, 2026
